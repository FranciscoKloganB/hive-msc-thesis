<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>app.domain.helpers.matrices</title>
    

    <link rel="stylesheet" href="../../../../_static/css/redactor.css" type="text/css" />
    
    
    <link rel="index" title="Index" href="../../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="Hives 1.0 documentation" href="../../../../index.html"/>
    <link rel="up" title="Module code" href="../../../index.html"/> 
</head>

<body role="document">
     

    
<a href="#" id="js-navigation-toggle" class="navigation-toggle">
    <i class="mdi mdi-menu"></i><i class="mdi mdi-close"></i>
</a>

<section class="site-sidebar">

<nav>


    <a href="../../../../index.html" class="branding-link">
    
        Hives
    
    
    
        
        
    
    </a>

    
<section role="search">
    <form action="../../../../search.html" method="get" class="site-searchform">
        <input type="text" name="q" placeholder="Search docs" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
</section>



    <section class="site-nav">
    
    
        <div></div>
    
    </section>

</nav>

</section>

    <main class="site-main" role="main">
        











<nav class="site-breadcrumbs">
    <ul>
    
        <li>
            <a href="../../../../index.html">Docs</a> /
        </li>
        
        <li>
            <a href="../../../index.html">Module code</a> /
        </li>
        
        <li class="site-breadcrumbs__leaf">app.domain.helpers.matrices</li>
    
    </ul>
</nav>
        <section class="site-content">
            <div class="container">
                
  <h1>Source code for app.domain.helpers.matrices</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module used by :py:class:`~domain.cluster_groups.Cluster to create transition</span>
<span class="sd">matrices for the simulation.</span>

<span class="sd">You should implement your own metropolis-hastings or alternative algorithms</span>
<span class="sd">as well as any steady-state or transition matrix optimization algorithms in</span>
<span class="sd">this module.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cvx</span>

<span class="kn">from</span> <span class="nn">matlab.engine</span> <span class="kn">import</span> <span class="n">EngineError</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">connected_components</span>

<span class="kn">from</span> <span class="nn">domain.helpers.matlab_utils</span> <span class="kn">import</span> <span class="n">MatlabEngineContainer</span>
<span class="kn">from</span> <span class="nn">domain.helpers.exceptions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">utils.randoms</span> <span class="kn">import</span> <span class="n">random_index</span>

<span class="n">OPTIMAL_STATUS</span> <span class="o">=</span> <span class="p">{</span><span class="n">cvx</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">cvx</span><span class="o">.</span><span class="n">OPTIMAL_INACCURATE</span><span class="p">}</span>


<span class="c1"># region Markov Matrix Constructors</span>
<div class="viewcode-block" id="new_mh_transition_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.new_mh_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">new_mh_transition_matrix</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot; Constructs a transition matrix using metropolis-hastings.</span>

<span class="sd">    Constructs a transition matrix using metropolis-hastings algorithm  for</span>
<span class="sd">    the specified steady state `v`.</span>

<span class="sd">    Note:</span>
<span class="sd">        The input Matrix hould have no transient states or absorbent nodes,</span>
<span class="sd">        but this is not enforced or verified.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            A symmetric adjency matrix.</span>
<span class="sd">        v_:</span>
<span class="sd">            A stochastic steady state distribution vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Markov Matrix with `v_` as steady state distribution and the</span>
<span class="sd">        respective mixing rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_metropolis_hastings</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">get_mixing_rate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="new_sdp_mh_transition_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.new_sdp_mh_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">new_sdp_mh_transition_matrix</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Constructs an optimized transition matrix using cvxpy and MOSEK solver.</span>

<span class="sd">    Constructs a transition matrix using metropolis-hastings algorithm  for</span>
<span class="sd">    the specified steady state `v`. The provided adjacency matrix A is first</span>
<span class="sd">    optimized with semi-definite programming techniques for the uniform</span>
<span class="sd">    distribution vector.</span>

<span class="sd">    Note:</span>
<span class="sd">        This function only works if you have a valid MOSEK license.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            A non-optimized symmetric adjency matrix.</span>
<span class="sd">        v_:</span>
<span class="sd">            A stochastic steady state distribution vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Markov Matrix with `v_` as steady state distribution and the</span>
<span class="sd">        respective mixing rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">problem</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">_adjency_matrix_sdp_optimization</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="n">OPTIMAL_STATUS</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_metropolis_hastings</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">get_mixing_rate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">cvx</span><span class="o">.</span><span class="n">SolverError</span><span class="p">,</span> <span class="n">cvx</span><span class="o">.</span><span class="n">DCPError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="new_go_transition_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.new_go_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">new_go_transition_matrix</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Constructs an optimized transition matrix using cvxpy and MOSEK solver.</span>

<span class="sd">    Constructs an optimized markov matrix using linear programming relaxations</span>
<span class="sd">    and convex envelope approximations for the specified steady state `v`.</span>
<span class="sd">    Result is only trully optimal if normal(Tranistion Matrix Opt - Uniform</span>
<span class="sd">    Matrix, 2) is equal to the markov matrix eigenvalue.</span>

<span class="sd">    Note:</span>
<span class="sd">        This function only works if you have a valid MOSEK license.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            A non-optimized symmetric adjency matrix.</span>
<span class="sd">        v_:</span>
<span class="sd">            A stochastic steady state distribution vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Markov Matrix with `v_` as steady state distribution and the</span>
<span class="sd">        respective mixing rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate python variables</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ones_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># np.ones((3,1)) shape is (3, 1)... whereas np.ones(n) shape is (3,), the latter is closer to cvxpy representation of vector</span>
    <span class="n">ones_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">zeros_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># Specificy problem variables</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="c1"># Create constraints - Python @ is Matrix Multiplication (MatLab equivalent is *), # Python * is Element-Wise Multiplication (MatLab equivalent is .*)</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Aopt entries must be non-negative</span>
        <span class="p">(</span><span class="n">t</span> <span class="o">@</span> <span class="n">ones_vector</span><span class="p">)</span> <span class="o">==</span> <span class="n">ones_vector</span><span class="p">,</span>  <span class="c1"># Aopt lines are stochastics, thus all entries in a line sum to one and are necessarely smaller than one</span>
        <span class="n">cvx</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ones_matrix</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">zeros_matrix</span><span class="p">,</span>  <span class="c1"># optimized matrix has no new connections. It may have less than original adjencency matrix</span>
        <span class="p">(</span><span class="n">v_</span> <span class="o">@</span> <span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_</span><span class="p">,</span>  <span class="c1"># Resulting matrix must be a markov matrix.</span>
    <span class="p">]</span>

    <span class="c1"># Formulate and Solve Problem</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">objective</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">cvx</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="n">OPTIMAL_STATUS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">get_mixing_rate</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">cvx</span><span class="o">.</span><span class="n">SolverError</span><span class="p">,</span> <span class="n">cvx</span><span class="o">.</span><span class="n">DCPError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="new_mgo_transition_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.new_mgo_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">new_mgo_transition_matrix</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Constructs an optimized transition matrix using the matlab engine.</span>

<span class="sd">    Constructs an optimized transition matrix using linear programming</span>
<span class="sd">    relaxations and convex envelope approximations for the specified steady</span>
<span class="sd">    state `v`. Result is only trully optimal if normal(Tranistion Matrix Opt</span>
<span class="sd">    - Uniform Matrix, 2) is equal to the markov matrix eigenvalue. The code</span>
<span class="sd">    is run on a matlab engine because it provides a non-convex SDP solver ç</span>
<span class="sd">    BMIBNB.</span>

<span class="sd">    Note:</span>
<span class="sd">        This function can only be invoked if you have a valid matlab license.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            A non-optimized symmetric adjency matrix.</span>
<span class="sd">        v_:</span>
<span class="sd">            A stochastic steady state distribution vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Markov Matrix with `v_` as steady state distribution and the</span>
<span class="sd">        respective mixing rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matlab_container</span> <span class="o">=</span> <span class="n">MatlabEngineContainer</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">matlab_container</span><span class="o">.</span><span class="n">matrix_global_opt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">get_mixing_rate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">EngineError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span></div>
<span class="c1"># endregion</span>


<span class="c1"># region SDP Optimization</span>
<div class="viewcode-block" id="_adjency_matrix_sdp_optimization"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices._adjency_matrix_sdp_optimization">[docs]</a><span class="k">def</span> <span class="nf">_adjency_matrix_sdp_optimization</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cvx</span><span class="o">.</span><span class="n">Problem</span><span class="p">,</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Optimizes a symmetric adjacency matrix using Semidefinite Programming.</span>

<span class="sd">    The optimization is done with respect to the uniform stochastic vector</span>
<span class="sd">    with the the same length as the inputed symmetric matrix.</span>

<span class="sd">    Note:</span>
<span class="sd">        1. This function only works if you have a valid MOSEK license.</span>
<span class="sd">        2. The input Matrix hould have no transient states/absorbent nodes, \</span>
<span class="sd">        but this is not enforced or verified.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            Any symmetric adjacency matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The optimal matrix or None if the problem is unfeasible.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Allocate python variables</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ones_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># np.ones((3,1)) shape is (3, 1)... whereas np.ones(n) shape is (3,), the latter is closer to cvxpy representation of vector</span>
    <span class="n">ones_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">zeros_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">n</span>

    <span class="c1"># Specificy problem variables</span>
    <span class="n">a_opt</span><span class="p">:</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Variable</span><span class="p">()</span>
    <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Create constraints - Python @ is Matrix Multiplication (MatLab equivalent is *), # Python * is Element-Wise Multiplication (MatLab equivalent is .*)</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">a_opt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># a_opt entries must be non-negative</span>
        <span class="p">(</span><span class="n">a_opt</span> <span class="o">@</span> <span class="n">ones_vector</span><span class="p">)</span> <span class="o">==</span> <span class="n">ones_vector</span><span class="p">,</span>  <span class="c1"># a_opt lines are stochastics, thus all entries in a line sum to one and are necessarely smaller than one</span>
        <span class="n">cvx</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a_opt</span><span class="p">,</span> <span class="n">ones_matrix</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">zeros_matrix</span><span class="p">,</span>  <span class="c1"># optimized matrix has no new connections. It may have less than original adjencency matrix</span>
        <span class="p">(</span><span class="n">a_opt</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>  <span class="c1"># eigenvalue lower bound, cvxpy does not accept chained constraints, e.g.: 0 &lt;= x &lt;= 1</span>
        <span class="p">(</span><span class="n">a_opt</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># eigenvalue upper bound</span>
    <span class="p">]</span>

    <span class="c1"># Formulate and Solve Problem</span>
    <span class="n">objective</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">cvx</span><span class="o">.</span><span class="n">MOSEK</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">problem</span><span class="p">,</span> <span class="n">a_opt</span></div>
<span class="c1"># endregion</span>


<span class="c1"># region Metropolis Hastings</span>
<div class="viewcode-block" id="_metropolis_hastings"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices._metropolis_hastings">[docs]</a><span class="k">def</span> <span class="nf">_metropolis_hastings</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">column_major_out</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Constructs a transition matrix using metropolis-hastings algorithm.</span>

<span class="sd">    Note:</span>
<span class="sd">        The input Matrix hould have no transient states/absorbent nodes,</span>
<span class="sd">        but this is not enforced or verified.</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            A symmetric adjency matrix.</span>
<span class="sd">        v_:</span>
<span class="sd">            A stochastic vector that is the steady state of the resulting</span>
<span class="sd">            transition matrix.</span>
<span class="sd">        column_major_out:</span>
<span class="sd">            optional; Indicates whether to return transition_matrix output</span>
<span class="sd">            is in row or column major form.</span>
<span class="sd">        version:</span>
<span class="sd">            optional; Indicates which version of the algorith should be used</span>
<span class="sd">            (default is 2, for version 2).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An unlabeled transition matrix with steady state `v_`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        DistributionShapeError:</span>
<span class="sd">            When the length of `v_` is not the same as the matrix `a`.</span>
<span class="sd">        MatrixNotSquareError:</span>
<span class="sd">            When matrix `a` is not a square matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">v_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">DistributionShapeError</span><span class="p">(</span>
            <span class="s2">&quot;distribution shape: </span><span class="si">{}</span><span class="s2">, proposal matrix shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">v_</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">MatrixNotSquareError</span><span class="p">(</span>
            <span class="s2">&quot;rows: </span><span class="si">{}</span><span class="s2">, columns: </span><span class="si">{}</span><span class="s2">, expected square matrix&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">rw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_construct_random_walk_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">rw</span> <span class="o">=</span> <span class="n">rw</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_construct_rejection_matrix</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>

    <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__get_diagonal_entry_probability</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__get_diagonal_entry_probability_v2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">column_major_out</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="_construct_random_walk_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices._construct_random_walk_matrix">[docs]</a><span class="k">def</span> <span class="nf">_construct_random_walk_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Builds a random walk matrix over the given adjacency matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        a:</span>
<span class="sd">            Any adjacency matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A matrix representing the performed random walk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Version 1.</span>
    <span class="c1"># shape = a.shape</span>
    <span class="c1"># size = shape[0]</span>
    <span class="c1"># rw: np.ndarray = np.zeros(shape=shape)</span>
    <span class="c1"># for i in range(size):</span>
    <span class="c1">#     # all possible states reachable from state i, including self</span>
    <span class="c1">#     degree: Any = np.sum(a[i, :])</span>
    <span class="c1">#     for j in range(size):</span>
    <span class="c1">#         rw[i, j] = a[i, j] / degree</span>
    <span class="c1"># return rw</span>
    <span class="c1"># Version 2 - Returns Column Major Random Walk, similar to MatLab.</span>
    <span class="c1">#   To return a equivalent of version 1 output, transpose the result.</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="_construct_rejection_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices._construct_rejection_matrix">[docs]</a><span class="k">def</span> <span class="nf">_construct_rejection_matrix</span><span class="p">(</span><span class="n">rw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Builds a matrix of rejection probabilities for a given random walk.</span>

<span class="sd">    Args:</span>
<span class="sd">        v_:</span>
<span class="sd">            a stochastic desired distribution vector</span>
<span class="sd">        rw:</span>
<span class="sd">            a random_walk over an adjacency matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        A matrix whose entries are acceptance probabilities for the random walk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">rw</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">rw</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">v_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="__get_diagonal_entry_probability"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.__get_diagonal_entry_probability">[docs]</a><span class="k">def</span> <span class="nf">__get_diagonal_entry_probability</span><span class="p">(</span>
        <span class="n">rw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper function used by</span>
<span class="sd">    :py:func:`app.domain.helpers.matrices._metropolis_hastings` function.</span>

<span class="sd">    Calculates the value that should be assigned to the entry (i, i) of the</span>
<span class="sd">    transition matrix being calculated by the metropolis hastings algorithm</span>
<span class="sd">    by considering the rejection probability over the random walk that was</span>
<span class="sd">    performed on an adjacency matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        rw:</span>
<span class="sd">            A random_walk over an adjacency matrix.</span>
<span class="sd">        r:</span>
<span class="sd">            A matrix whose entries contain acceptance probabilities for rw.</span>
<span class="sd">        i:</span>
<span class="sd">            The diagonal-index of the random walk where summation needs to</span>
<span class="sd">            be performed on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A probability to be inserted at entry (i, i) of the transition matrix</span>
<span class="sd">        outputed by the _metropolis_hastings function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">rw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pii</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">=</span> <span class="n">rw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="n">pii</span> <span class="o">+=</span> <span class="n">rw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">pii</span></div>


<div class="viewcode-block" id="__get_diagonal_entry_probability_v2"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.__get_diagonal_entry_probability_v2">[docs]</a><span class="k">def</span> <span class="nf">__get_diagonal_entry_probability_v2</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper function used by _metropolis_hastings function.</span>

<span class="sd">        Calculates the value that should be assigned to the entry (i, i) of the</span>
<span class="sd">        transition matrix being calculated by the metropolis hastings algorithm</span>
<span class="sd">        by considering the rejection probability over the random walk that was</span>
<span class="sd">        performed on an adjacency matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            m:</span>
<span class="sd">                The matrix to receive the diagonal entry value.</span>
<span class="sd">            i:</span>
<span class="sd">                The diagonal entry index. E.g.: m[i, i].</span>

<span class="sd">        Returns:</span>
<span class="sd">            A probability to be inserted at entry (i, i) of the transition matrix</span>
<span class="sd">            outputed by the _metropolis_hastings function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span></div>
<span class="c1"># endregion</span>


<span class="c1"># region Helpers</span>
<div class="viewcode-block" id="get_mixing_rate"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.get_mixing_rate">[docs]</a><span class="k">def</span> <span class="nf">get_mixing_rate</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculats the fast mixing rate the input matrix.</span>

<span class="sd">    The fast mixing rate of matrix M is the highest eigenvalue that is</span>
<span class="sd">    smaller than one. If returned value is 1.0 than the matrix has transient</span>
<span class="sd">    states or absorbent nodes.</span>

<span class="sd">    Args:</span>
<span class="sd">        m:</span>
<span class="sd">            A matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The highest eigenvalue of `m` that is smaller than one or one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">MatrixNotSquareError</span><span class="p">(</span>
            <span class="s2">&quot;Can not compute eigenvalues/vectors with non-square matrix&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">/</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">mixing_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mixing_rate</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>


<div class="viewcode-block" id="new_symmetric_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.new_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">new_symmetric_matrix</span><span class="p">(</span>
        <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">allow_sloops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force_sloops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generates a random symmetric matrix.</span>

<span class="sd">     The generated adjacency matrix does not have transient state sets or</span>
<span class="sd">     absorbent nodes and can effectively represent a network topology</span>
<span class="sd">     with bidirectional connections between network nodes.</span>

<span class="sd">     Args:</span>
<span class="sd">         size:</span>
<span class="sd">            The length of the square matrix.</span>
<span class="sd">         allow_sloops:</span>
<span class="sd">            Indicates if the generated adjacency matrix allows diagonal</span>
<span class="sd">            entries representing self-loops. If false, then, all diagonal</span>
<span class="sd">            entries must be zeros. Otherwise, they can be zeros or ones (</span>
<span class="sd">            default is True).</span>
<span class="sd">         force_sloops:</span>
<span class="sd">            Indicates if the diagonal of the generated matrix should be</span>
<span class="sd">            filled with ones. If false, valid diagonal entries are decided by</span>
<span class="sd">            `allow_self_loops` param. Otherwise, diagonal entries are filled</span>
<span class="sd">            with ones. If `allow_self_loops` is False and `enforce_loops` is</span>
<span class="sd">            True, an error is raised (default is True).</span>

<span class="sd">    Returns:</span>
<span class="sd">        The adjency matrix representing the connections between a</span>
<span class="sd">        groups of network nodes.</span>

<span class="sd">    Raises:</span>
<span class="sd">        IllegalArgumentError:</span>
<span class="sd">            When `allow_self_loops` (False) conflicts with</span>
<span class="sd">            `enforce_loops` (True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sloops</span> <span class="ow">and</span> <span class="n">force_sloops</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">IllegalArgumentError</span><span class="p">(</span><span class="s2">&quot;Can not invoke new_symmetric_matrix with:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                   <span class="s2">&quot;    [x] allow_sloops=False</span><span class="se">\n</span><span class="s2">&quot;</span>
                                   <span class="s2">&quot;    [x] force_sloops=True&quot;</span><span class="p">)</span>
    <span class="n">secure_random</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">SystemRandom</span><span class="p">()</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sloops</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">force_sloops</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__new_edge_val__</span><span class="p">(</span><span class="n">secure_random</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__new_edge_val__</span><span class="p">(</span><span class="n">secure_random</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="new_symmetric_connected_matrix"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.new_symmetric_connected_matrix">[docs]</a><span class="k">def</span> <span class="nf">new_symmetric_connected_matrix</span><span class="p">(</span>
        <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">allow_sloops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force_sloops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generates a random symmetric matrix which is also connected.</span>

<span class="sd">    See :py:func:`~domain.helpers.matrices.new_symmetric_matrix` and</span>
<span class="sd">    py:func:`~domain.helpers.matrices.make_connected`.</span>

<span class="sd">     Args:</span>
<span class="sd">         size:</span>
<span class="sd">            The length of the square matrix.</span>
<span class="sd">         allow_sloops:</span>
<span class="sd">            See :py:func:`~domain.helpers.matrices.new_symmetric_matrix`.</span>
<span class="sd">         force_sloops:</span>
<span class="sd">            See :py:func:`~domain.helpers.matrices.new_symmetric_matrix`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A matrix that represents an adjacency matrix that is also connected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_symmetric_matrix</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_connected</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">make_connected</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="make_connected"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.make_connected">[docs]</a><span class="k">def</span> <span class="nf">make_connected</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Turns a matrix into a connected matrix that could represent a</span>
<span class="sd">    connected graph.</span>

<span class="sd">    Args:</span>
<span class="sd">        m: The matrix to be made connected.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A connected matrix. If the inputed matrix was connected it will</span>
<span class="sd">        remain so.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Use guilty until proven innocent approach for both checks</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="n">is_absorbent_or_transient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="c1"># Ensure state i can reach and be reached by some other state j</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">is_absorbent_or_transient</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">is_absorbent_or_transient</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">random_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="is_symmetric"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.is_symmetric">[docs]</a><span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Checks if a matrix is symmetric by comparing entries of a and a.T.</span>

<span class="sd">    Args:</span>
<span class="sd">        m:</span>
<span class="sd">            The matrix to be verified.</span>
<span class="sd">        tol:</span>
<span class="sd">            The tolerance used to verify the entries of the matrix (default</span>
<span class="sd">            is 1e-8).</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the matrix is symmetric, else False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_connected"><a class="viewcode-back" href="../../../../app.domain.helpers.html#app.domain.helpers.matrices.is_connected">[docs]</a><span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Checks if a matrix is connected by counting the number of connected</span>
<span class="sd">    components.</span>

<span class="sd">    Args:</span>
<span class="sd">        m:</span>
<span class="sd">            The matrix to be verified.</span>
<span class="sd">        directed:</span>
<span class="sd">            If the matrix edges are directed, i.e., if the matrix is an adjency</span>
<span class="sd">            matrix are the edges bidirectional, where false means they are (</span>
<span class="sd">            default is false).</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the matrix is a connected graph, else False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">cc_labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span></div>


<span class="k">def</span> <span class="nf">__new_edge_val__</span><span class="p">(</span><span class="n">random_generator</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">SystemRandom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">random_generator</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># endregion</span>
</pre></div>

            </div>

        </section>

        

        
            <div class="source-link">
            
                
            
            </div>
        



    </main>

    <footer class="site-footer">
<div class="container">

    <div role="contentinfo">
        <p>
                &copy; Copyright 2020, Francisco Barros.
        </p>
    </div>
        <p>Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
        <a href="https://github.com/testthedocs/sphinx_ttd_theme">theme</a>
        provided by <a href="https://testthedocs">TestTheDocs</a>. 

</div>
</footer>

    

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../../_static/js/theme-min.js"></script> 
</body>
</html>