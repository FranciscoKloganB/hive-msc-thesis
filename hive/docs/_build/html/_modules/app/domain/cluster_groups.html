<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>app.domain.cluster_groups</title>
    

    <link rel="stylesheet" href="../../../_static/css/redactor.css" type="text/css" />
    
    
    <link rel="index" title="Index" href="../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Hives - P2P Stochastic Swarm Guidance Simulator" href="../../../index.html"/>
    <link rel="up" title="Module code" href="../../index.html"/> 
</head>

<body role="document">
     

    
<a href="#" id="js-navigation-toggle" class="navigation-toggle">
    <i class="mdi mdi-menu"></i><i class="mdi mdi-close"></i>
</a>

<section class="site-sidebar">

<nav>


    <a href="../../../index.html" class="branding-link">
    
        Hives
    
    
    
        
        
            <span class="branding-link__version">
                1.6
            </span>
        
    
    </a>

    
<section role="search">
    <form action="../../../search.html" method="get" class="site-searchform">
        <input type="text" name="q" placeholder="Search docs" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
</section>



    <section class="site-nav">
    
    
        <p class="caption"><span class="caption-text">Navbar</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstartdocs.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scriptdocs.html">Scripts and Flags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../app.html">App Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notedocs.html">Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../indices.html">Indices</a></li>
</ul>

    
    </section>

</nav>

</section>

    <main class="site-main" role="main">
        











<nav class="site-breadcrumbs">
    <ul>
    
        <li>
            <a href="../../../index.html">Docs</a> /
        </li>
        
        <li>
            <a href="../../index.html">Module code</a> /
        </li>
        
        <li class="site-breadcrumbs__leaf">app.domain.cluster_groups</li>
    
    </ul>
</nav>
        <section class="site-content">
            <div class="container">
                
  <h1>Source code for app.domain.cluster_groups</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module contains domain specific classes that represent groups of</span>
<span class="sd">:py:mod:`storage nodes &lt;app.domain.network_nodes&gt;`.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">type_hints</span> <span class="k">as</span> <span class="nn">th</span>
<span class="kn">import</span> <span class="nn">environment_settings</span> <span class="k">as</span> <span class="nn">es</span>
<span class="kn">import</span> <span class="nn">domain.master_servers</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">import</span> <span class="nn">domain.helpers.enums</span> <span class="k">as</span> <span class="nn">e</span>
<span class="kn">import</span> <span class="nn">domain.helpers.matrices</span> <span class="k">as</span> <span class="nn">mm</span>
<span class="kn">import</span> <span class="nn">domain.helpers.smart_dataclasses</span> <span class="k">as</span> <span class="nn">sd</span>


<div class="viewcode-block" id="Cluster"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster">[docs]</a><span class="k">class</span> <span class="nc">Cluster</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents a group of network nodes ensuring the durability of a file.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        id (str):</span>
<span class="sd">            A unique identifier of the ``Cluster`` instance.</span>
<span class="sd">        current_epoch (int):</span>
<span class="sd">            The simulation&#39;s current epoch.</span>
<span class="sd">        corruption_chances (List[float]):</span>
<span class="sd">            A two-element list containing the probability of</span>
<span class="sd">            :py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`</span>
<span class="sd">            being corrupted and not being corrupted, respectively. See</span>
<span class="sd">            :py:func:`~app.environment_settings.get_disk_error_chances`</span>
<span class="sd">            for corruption chance configuration.</span>
<span class="sd">        master (:py:class:`~app.domain.master_servers.Master`):</span>
<span class="sd">            A reference to a server that coordinates or monitors the ``Cluster``.</span>
<span class="sd">        members (:py:class:`~app.type_hints.NodeDict`):</span>
<span class="sd">            A collection of network nodes that belong to the ``Cluster``.</span>
<span class="sd">        _members_view (List[:py:class:`~app.type_hints.NodeType`]):</span>
<span class="sd">            A list representation of the nodes in :py:attr:`members`.</span>
<span class="sd">        file (:py:class:`~app.domain.helpers.smart_dataclasses.FileData`):</span>
<span class="sd">            A reference to</span>
<span class="sd">            :py:class:`~app.domain.helpers.smart_dataclasses.FileData`</span>
<span class="sd">            object that represents the file being persisted by the Cluster</span>
<span class="sd">            instance.</span>
<span class="sd">        critical_size (int):</span>
<span class="sd">            Minimum number of network nodes plus required to exist in the</span>
<span class="sd">            Cluster to assure the target replication level.</span>
<span class="sd">        sufficient_size (int):</span>
<span class="sd">             Sum of :py:attr:`~app.domain.cluster_groups.Cluster.critical_size`</span>
<span class="sd">             and the number of nodes expected to fail between two successive</span>
<span class="sd">             recovery phases.</span>
<span class="sd">        original_size (int):</span>
<span class="sd">            The initial and theoretically optimal</span>
<span class="sd">            :py:class:`~app.domain.cluster_groups.Cluster` size.</span>
<span class="sd">        redundant_size (int):</span>
<span class="sd">            Application-specific parameter, which indicates that membership</span>
<span class="sd">            of the Cluster must be pruned.</span>
<span class="sd">        running (bool):</span>
<span class="sd">            Indicates if the Cluster instance is active. Used by</span>
<span class="sd">            :py:class:`~app.domain.master_servers.Master` to manage the</span>
<span class="sd">            simulation processes.</span>
<span class="sd">        _membership_changed (bool):</span>
<span class="sd">            Flag indicates wether or not :py:attr:`_members_view` needs</span>
<span class="sd">            to be updated during :py:meth:`membership_maintenance`. The</span>
<span class="sd">            variable is set to false at the beggining of every epoch and set</span>
<span class="sd">            to true if the length of ``off_nodes`` list return by</span>
<span class="sd">            :py:meth:`nodes_execute` is bigger than zero.</span>
<span class="sd">        _recovery_epoch_sum (int):</span>
<span class="sd">            Helper attribute that facilitates the storage of the sum of the</span>
<span class="sd">            values returned by all</span>
<span class="sd">            :py:meth:`~app.domain.helpers.smart_dataclasses.FileBlockData.set_recovery_epoch`</span>
<span class="sd">            method calls. Important for logging purposes.</span>
<span class="sd">        _recovery_epoch_calls (int):</span>
<span class="sd">            Helper attribute that facilitates the storage of the sum of the</span>
<span class="sd">            values returned by all</span>
<span class="sd">            :py:meth:`~app.domain.helpers.smart_dataclasses.FileBlockData.set_recovery_epoch`</span>
<span class="sd">            method calls throughout the :py:attr:`current_epoch`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Cluster.__init__"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">master</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">MasterType</span><span class="p">,</span>
                 <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">,</span>
                 <span class="n">sim_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiates an ``Cluster`` object</span>

<span class="sd">        Args:</span>
<span class="sd">            master (:py:class:`~app.type_hints.MasterType`):</span>
<span class="sd">                A reference to an :py:class:`~app.domain.master_servers.Master`</span>
<span class="sd">                object that manages the ``Cluster`` being initialized.</span>
<span class="sd">            file_name:</span>
<span class="sd">                The name of the file the ``Cluster`` is responsible for</span>
<span class="sd">                persisting.</span>
<span class="sd">            members (:py:class:`~app.type_hints.NodeDict`):</span>
<span class="sd">                A dictionary where keys are :py:attr:`node identifiers</span>
<span class="sd">                &lt;app.domain.network_nodes.Node.id&gt;` and values are their</span>
<span class="sd">                :py:class:`instance objects &lt;app.domain.network_nodes.Node&gt;`.</span>
<span class="sd">            sim_id:</span>
<span class="sd">                Identifier that generates unique output file names,</span>
<span class="sd">                thus guaranteeing that different simulation instances do not</span>
<span class="sd">                overwrite previous out files.</span>
<span class="sd">            origin:</span>
<span class="sd">                The name of the simulation file name that started</span>
<span class="sd">                the simulation process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corruption_chances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">get_disk_error_chances</span><span class="p">(</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">Master</span><span class="o">.</span><span class="n">MAX_EPOCHS</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span> <span class="o">=</span> <span class="n">members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">_</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}{</span><span class="n">origin</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">:</span> <span class="n">sd</span><span class="o">.</span><span class="n">FileData</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">FileData</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>

        <span class="n">expected_fails</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.34</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">critical_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">REPLICATION_LEVEL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_size</span> <span class="o">+</span> <span class="n">expected_fails</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redundant_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_size</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_sum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_calls</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="c1"># region Cluster API</span>
<div class="viewcode-block" id="Cluster.route_part"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.route_part">[docs]</a>    <span class="k">def</span> <span class="nf">route_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">sender</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">receiver</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">replica</span><span class="p">:</span> <span class="n">sd</span><span class="o">.</span><span class="n">FileBlockData</span><span class="p">,</span>
                   <span class="n">is_fresh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sends a :py:class:`file block replica</span>
<span class="sd">        &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;` to some other</span>
<span class="sd">        :py:class:`network node &lt;app.domain.network_nodes.Node&gt;` in</span>
<span class="sd">        :py:attr:`members`.</span>

<span class="sd">        Args:</span>
<span class="sd">            sender:</span>
<span class="sd">                An identifier of the</span>
<span class="sd">                :py:class:`network node &lt;app.domain.network_nodes.Node&gt;`</span>
<span class="sd">                who is sending the message.</span>
<span class="sd">            receiver:</span>
<span class="sd">                The destination</span>
<span class="sd">                :py:class:`network node &lt;app.domain.network_nodes.Node&gt;`</span>
<span class="sd">                identifier.</span>
<span class="sd">            replica (:py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`):</span>
<span class="sd">                The :py:class:`file block replica &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;`</span>
<span class="sd">                to be sent specified destination: ``receiver``.</span>
<span class="sd">            is_fresh:</span>
<span class="sd">                Prevents recently created replicas from being</span>
<span class="sd">                corrupted, since they are not likely to be corrupted in disk.</span>
<span class="sd">                This argument facilitates simulation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An http code sent by the ``receiver``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sender</span> <span class="o">==</span> <span class="n">receiver</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">HttpCodes</span><span class="o">.</span><span class="n">DUMMY</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_bandwidth_units</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>

        <span class="n">tf</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">TRUE_FALSE</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">es</span><span class="o">.</span><span class="n">COMMUNICATION_CHANCES</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_lost_messages</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">HttpCodes</span><span class="o">.</span><span class="n">TIME_OUT</span>

        <span class="n">is_corrupted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">tf</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corruption_chances</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_fresh</span> <span class="ow">and</span> <span class="n">is_corrupted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_corrupted_file_blocks</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">HttpCodes</span><span class="o">.</span><span class="n">BAD_REQUEST</span>

        <span class="n">destination_node</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="n">receiver</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">destination_node</span><span class="o">.</span><span class="n">is_up</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">destination_node</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">HttpCodes</span><span class="o">.</span><span class="n">NOT_FOUND</span></div>

<div class="viewcode-block" id="Cluster.complain"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.complain">[docs]</a>    <span class="k">def</span> <span class="nf">complain</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">complainter</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">complainee</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">HttpResponse</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Registers a complaint against a possibly offline node.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method provides no default functionality and should be</span>
<span class="sd">            overridden in sub classes if required.</span>

<span class="sd">        Args:</span>
<span class="sd">            complainter:</span>
<span class="sd">                The identifier of the complaining :py:class:`network node</span>
<span class="sd">                &lt;app.domain.network_nodes.Node&gt;`.</span>
<span class="sd">            complainee:</span>
<span class="sd">                The identifier of the :py:class:`network node</span>
<span class="sd">                &lt;app.domain.network_nodes.Node&gt;` being complained about.</span>
<span class="sd">            reason (:py:data:`app.type_hints.HttpResponse`):</span>
<span class="sd">                The :py:class:`http code &lt;app.domain.helpers.enums.HttpCodes&gt;`</span>
<span class="sd">                that led to the complaint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Cluster.get_node"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.get_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrives a random node from the members of the cluster group,</span>
<span class="sd">        whose status is likely to be online.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~app.type_hints.NodeType`:</span>
<span class="sd">                A random network node from :py:attr:`members`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">))</span>
        <span class="n">candidate_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">candidate_node</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation setup</span>
<div class="viewcode-block" id="Cluster._setup_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster._setup_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initializes some attributes cluster attributes at the start of an</span>
<span class="sd">        epoch.</span>

<span class="sd">        This method also forces all of the ``Clusters`` members to update</span>
<span class="sd">        their connectivity status before any node is instructed to execute.</span>

<span class="sd">        Args:</span>
<span class="sd">            epoch:</span>
<span class="sd">                The simulation&#39;s current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span> <span class="o">=</span> <span class="n">epoch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_calls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="n">member</span><span class="o">.</span><span class="n">update_status</span><span class="p">()</span></div>

<div class="viewcode-block" id="Cluster.spread_files"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.spread_files">[docs]</a>    <span class="k">def</span> <span class="nf">spread_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replicas</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">ReplicasDict</span><span class="p">,</span> <span class="n">strat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Distributes a collection of :py:class:`file block replicas</span>
<span class="sd">        &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;` among the</span>
<span class="sd">        :py:attr:`members` of the cluster group.</span>

<span class="sd">        Args:</span>
<span class="sd">            replicas (:py:class:`~app.type_hints.ReplicasDict`):</span>
<span class="sd">                The :py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`</span>
<span class="sd">                replicas, without replication.</span>
<span class="sd">            strat:</span>
<span class="sd">                Defines how ``replicas`` will be initially distributed in</span>
<span class="sd">                the ``Cluster``. Unless overridden in children of this class the</span>
<span class="sd">                received value of ``strat`` will be ignored and will always</span>
<span class="sd">                be set to the default value ``i``.</span>

<span class="sd">                i</span>
<span class="sd">                    This strategy creates a probability vector</span>
<span class="sd">                    containing the normalization of :py:attr:`network nodes</span>
<span class="sd">                    uptimes&#39; &lt;app.domain.network_nodes.Node.uptime&gt;` and uses</span>
<span class="sd">                    that vector to randomly select which</span>
<span class="sd">                    :py:class:`node &lt;app.domain.network_nodes.Node&gt;` will</span>
<span class="sd">                    receive each replica. There is a bias to give more</span>
<span class="sd">                    replicas to the most resillent :py:class:`nodes</span>
<span class="sd">                    &lt;app.domain.network_nodes.Node&gt;` which results from</span>
<span class="sd">                    using the created probability vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">initial_spread</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span>

        <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span>
        <span class="n">uptime_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">uptime</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">)</span>
        <span class="n">chances</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">uptime</span> <span class="o">/</span> <span class="n">uptime_sum</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">choice_view</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>
            <span class="n">selected_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="n">a</span><span class="o">=</span><span class="n">choice_view</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">chances</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">es</span><span class="o">.</span><span class="n">REPLICATION_LEVEL</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">selected_nodes</span><span class="p">:</span>
                <span class="n">replica</span><span class="o">.</span><span class="n">references</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation steps</span>
<div class="viewcode-block" id="Cluster.execute_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.execute_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Orders all :py:attr:`members` to execute their epoch.</span>

<span class="sd">        Note:</span>
<span class="sd">            If the ``Cluster`` terminates early, before it reaches</span>
<span class="sd">            :py:const:`~app.domain.master_servers.Master.MAX_EPOCHS`,</span>
<span class="sd">            nothing should be logged in</span>
<span class="sd">            :py:class:`~app.domain.helpers.smart_dataclasses.LoggingData`</span>
<span class="sd">            at the specified ``epoch`` to avoid skewing previously</span>
<span class="sd">            collected results.</span>

<span class="sd">        Args:</span>
<span class="sd">            epoch:</span>
<span class="sd">                The epoch the ``Cluster`` should currently be in, according</span>
<span class="sd">                to it&#39;s managing :py:attr:`master` entity.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ``False`` if ``Cluster`` failed to persist the :py:attr:`file` it</span>
<span class="sd">            was responsible for, otherwise ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>

        <span class="n">off_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_execute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maintain</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">==</span> <span class="n">ms</span><span class="o">.</span><span class="n">Master</span><span class="o">.</span><span class="n">MAX_EPOCHS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_replication_delay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_sum</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_calls</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.nodes_execute"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.nodes_execute">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Queries all :py:attr:`members` to execute the epoch.</span>

<span class="sd">        This method logs the amount of lost replicas throughout</span>
<span class="sd">        :py:attr:`current_epoch` according to the :py:attr:`members` who went</span>
<span class="sd">        offline and the</span>
<span class="sd">        :py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`</span>
<span class="sd">        replicas they posssed and is responsible for</span>
<span class="sd">        :py:meth:`setting a replication epoch</span>
<span class="sd">        &lt;app.domain.cluster_groups.Cluster.set_replication_epoch&gt;`.</span>
<span class="sd">        Similarly it logs the number of members who disconnected.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~app.type_hints.NodeType`]:</span>
<span class="sd">                List of :py:attr:`members` that disconnected during the</span>
<span class="sd">                :py:attr:`current_epoch`. See</span>
<span class="sd">                :py:meth:`app.domain.network_nodes.Node.update_status`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.evaluate"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluates and logs the health, possibly other parameters, of the</span>
<span class="sd">        ``Cluster`` at every epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.maintain"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.maintain">[docs]</a>    <span class="k">def</span> <span class="nf">maintain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">off_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Offers basic maintenance functionality for Cluster types.</span>

<span class="sd">        If ``off_nodes`` list param as at least one node reference,</span>
<span class="sd">        :py:attr:`_membership_changed` is set to ``True``.</span>

<span class="sd">        Args:</span>
<span class="sd">            off_nodes:</span>
<span class="sd">                A possibly empty of offline nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Cluster.membership_maintenance"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.membership_maintenance">[docs]</a>    <span class="k">def</span> <span class="nf">membership_maintenance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attempts to recruits new network nodes to be members of the cluster.</span>

<span class="sd">        The method updates both :py:attr:`members` and :py:attr:`_members_view`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~app.type_hints.NodeDict`:</span>
<span class="sd">                A dictionary that is empty if membership did not change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sbm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>
        <span class="n">status_bm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_status</span><span class="p">()</span>

        <span class="n">new_members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">sbm</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span><span class="p">:</span>
            <span class="n">new_members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_new_members</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">new_members</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_members</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># Is this it?</span>

        <span class="n">sam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>
        <span class="n">status_am</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_status</span><span class="p">()</span>

        <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_maintenance</span><span class="p">(</span><span class="n">sbm</span><span class="p">,</span> <span class="n">sam</span><span class="p">,</span> <span class="n">status_bm</span><span class="p">,</span> <span class="n">status_am</span><span class="p">,</span> <span class="n">epoch</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_members</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Helpers</span>
<div class="viewcode-block" id="Cluster._log_evaluation"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster._log_evaluation">[docs]</a>    <span class="k">def</span> <span class="nf">_log_evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plive</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ptotal</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Helper that collects ``Cluster`` data and registers it on a</span>
<span class="sd">        :py:class:`logger &lt;app.domain.helpers.smart_dataclasses.LoggingData&gt;`</span>
<span class="sd">        object.</span>

<span class="sd">        Args:</span>
<span class="sd">            plive:</span>
<span class="sd">                The number of existing parts in the cluster at the</span>
<span class="sd">                simulation&#39;s current epoch at online or suspect nodes.</span>
<span class="sd">            ptotal:</span>
<span class="sd">                The number of existing parts in the cluster at the</span>
<span class="sd">                simulation&#39;s current epoch. This parameter is optional and</span>
<span class="sd">                may be used or not depending on the intent of the system.</span>
<span class="sd">                As a rule of thumb ``plive`` tracks the number of parts that</span>
<span class="sd">                are alive in the system for logging purposes, where as</span>
<span class="sd">                ``ptotal`` is used for comparisons and averages, e.g.,</span>
<span class="sd">                :py:meth:`SGCluster evaluate</span>
<span class="sd">                &lt;app.domain.cluster_groups.SGCluster.evaluate&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_existing_file_blocks</span><span class="p">(</span><span class="n">plive</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plive</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="s2">&quot;Cluster has no remaining parts.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">existing_replicas</span> <span class="o">=</span> <span class="n">ptotal</span></div>

<div class="viewcode-block" id="Cluster._set_fail"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster._set_fail">[docs]</a>    <span class="k">def</span> <span class="nf">_set_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Ends the Cluster instance simulation.</span>

<span class="sd">        Sets :py:attr:`running` to ``False`` and orders</span>
<span class="sd">        :py:class:`~app.domain.helpers.smart_dataclasses.FileData` to write</span>
<span class="sd">        :py:class:`collected logs &lt;app.domain.helpers.smart_dataclasses.LoggingData&gt;`</span>
<span class="sd">        to disk and close it&#39;s</span>
<span class="sd">        :py:attr:`~app.domain.helpers.smart_dataclasses.FileData.out_file`</span>
<span class="sd">        stream.</span>

<span class="sd">        Args:</span>
<span class="sd">            message:</span>
<span class="sd">                A short explanation of why the ``Cluster`` terminated early.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_fail</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster._get_new_members"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster._get_new_members">[docs]</a>    <span class="k">def</span> <span class="nf">_get_new_members</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Helper method that searches for possible</span>
<span class="sd">        :py:class:`network node &lt;app.domain.network_nodes.Node&gt;` by querying</span>
<span class="sd">        the :py:attr:`master` of the ``Cluster``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~app.type_hints.NodeDict`:</span>
<span class="sd">                A dictionary mapping where keys are</span>
<span class="sd">                :py:attr:`node identifiers &lt;app.domain.network_nodes.Node.id&gt;`</span>
<span class="sd">                and values are</span>
<span class="sd">                :py:class:`node instances &lt;app.domain.network_nodes.Node&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">master</span><span class="o">.</span><span class="n">find_online_nodes</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.get_cluster_status"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.get_cluster_status">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determines the ``Cluster``&#39;s status based on the length of the</span>
<span class="sd">        current :py:attr:`members` list.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The status of the ``Cluster`` as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redundant_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;redundant&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">redundant_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;stable&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_size</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;sufficient&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_size</span> <span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;unstable&quot;</span>
        <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;critical&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;dead&quot;</span></div>

<div class="viewcode-block" id="Cluster.set_replication_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.Cluster.set_replication_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">set_replication_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica</span><span class="p">:</span> <span class="n">sd</span><span class="o">.</span><span class="n">FileBlockData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Delegates to :py:meth:`~app.domain.helpers.smart_dataclasses.FileBlockData.set_replication_epoch`.</span>

<span class="sd">        Args:</span>
<span class="sd">            replica:</span>
<span class="sd">                The :py:class:`file block replica</span>
<span class="sd">                &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;` that</span>
<span class="sd">                was lost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">replica</span><span class="o">.</span><span class="n">set_replication_epoch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_sum</span> <span class="o">+=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recovery_epoch_calls</span> <span class="o">+=</span> <span class="mi">1</span></div></div>
    <span class="c1"># endregion</span>


<div class="viewcode-block" id="SGCluster"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster">[docs]</a><span class="k">class</span> <span class="nc">SGCluster</span><span class="p">(</span><span class="n">Cluster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a group of network nodes persisting a file using swarm</span>
<span class="sd">    guidance algorithm.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        v_ (:py:class:`~pd:pandas.DataFrame`):</span>
<span class="sd">            Density distribution cluster members must achieve with independent</span>
<span class="sd">            realizations for ideal persistence of the file.</span>
<span class="sd">        cv_ (:py:class:`~pd:pandas.DataFrame`):</span>
<span class="sd">            Tracks the file current density distribution, updated at each epoch.</span>
<span class="sd">        avg_ (:py:class:`~pd:pandas.DataFrame`):</span>
<span class="sd">            Tracks the file average density distribution. Used to assert if</span>
<span class="sd">            throughout the life time of a cluster, the desired density</span>
<span class="sd">            distribution :py:attr:`v_` was achieved on average. Differs from</span>
<span class="sd">            :py:attr:`cv_` because `cv_` is used for instantaneous</span>
<span class="sd">            convergence comparison.</span>
<span class="sd">        _timer (int):</span>
<span class="sd">            Used as a logical clock to divide the entries of :py:attr:`avg_`</span>
<span class="sd">            when a topology changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SGCluster.__init__"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">master</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">MasterType</span><span class="p">,</span>
                 <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">,</span>
                 <span class="n">sim_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_and_bcast_new_transition_matrix</span><span class="p">()</span></div>

    <span class="c1"># region Simulation setup</span>
<div class="viewcode-block" id="SGCluster.spread_files"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.spread_files">[docs]</a>    <span class="k">def</span> <span class="nf">spread_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replicas</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">ReplicasDict</span><span class="p">,</span> <span class="n">strat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Distributes a collection of</span>
<span class="sd">        :py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`</span>
<span class="sd">        objects among the :py:attr:`~Cluster.members` of the ``SGCluster``.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.spread_files`.</span>

<span class="sd">        Args:</span>
<span class="sd">            replicas (:py:class:`~app.type_hints.ReplicasDict`):</span>
<span class="sd">                The :py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`</span>
<span class="sd">                replicas, without replication.</span>
<span class="sd">            strat:</span>
<span class="sd">                Defines how ``replicas`` will be initially distributed in</span>
<span class="sd">                the ``Cluster``.</span>

<span class="sd">                u</span>
<span class="sd">                    Each :py:class:`file block replica</span>
<span class="sd">                    &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;` in</span>
<span class="sd">                    ``replicas`` is distributed following a</span>
<span class="sd">                    uniform probability vector among :py:attr:`members` of</span>
<span class="sd">                    the cluster group.</span>
<span class="sd">                a</span>
<span class="sd">                    Each :py:class:`file block replica</span>
<span class="sd">                    &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;`</span>
<span class="sd">                    in ``replicas`` is given up to ``N`` different</span>
<span class="sd">                    :py:attr:`members` where ``N`` is equal to</span>
<span class="sd">                    :py:const:`~app.environment_settings.REPLICATION_LEVEL`.</span>
<span class="sd">                i</span>
<span class="sd">                    Each :py:class:`file block replica</span>
<span class="sd">                    &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;`</span>
<span class="sd">                    in ``replicas`` with bias towards the</span>
<span class="sd">                    ideal steady state distribution. This implementation of</span>
<span class="sd">                    differs from</span>
<span class="sd">                    :py:meth:`app.domain.cluster_groups.Cluster.spread_files`,</span>
<span class="sd">                    because it is not necessarely based on</span>
<span class="sd">                    :py:class:`node &lt;app.domain.network_nodes.Node&gt;` uptime.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">initial_spread</span> <span class="o">=</span> <span class="n">strat</span>

        <span class="n">choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]</span>
        <span class="n">selected_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]</span>
        <span class="n">rl</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">REPLICATION_LEVEL</span>
        <span class="k">if</span> <span class="n">strat</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="n">selected_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">rl</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">selected_nodes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">replica</span><span class="o">.</span><span class="n">references</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">strat</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">selected_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                    <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">rl</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">selected_nodes</span><span class="p">:</span>
                    <span class="n">replica</span><span class="o">.</span><span class="n">references</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">strat</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span>
            <span class="n">desired_distribution</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">choices_view</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>
                <span class="n">selected_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                    <span class="n">a</span><span class="o">=</span><span class="n">choices_view</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">desired_distribution</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">rl</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">selected_nodes</span><span class="p">:</span>
                    <span class="n">replica</span><span class="o">.</span><span class="n">references</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation steps</span>
<div class="viewcode-block" id="SGCluster.execute_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.execute_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGCluster.nodes_execute"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.nodes_execute">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Queries all network node members execute the epoch.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.nodes_execute`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~app.type_hints.NodeType`]:</span>
<span class="sd">                 A collection of members who disconnected during the current</span>
<span class="sd">                 epoch. See</span>
<span class="sd">                 :py:meth:`app.domain.network_nodes.Node.update_status`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lost_parts_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">off_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_up</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_replicas</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">lost_parts_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_replicas</span><span class="p">)</span>
                <span class="n">off_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">node_replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_replication_epoch</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">replica</span><span class="o">.</span><span class="n">decrement_and_get_references</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lost all replicas of file replica with &quot;</span>
                                       <span class="sa">f</span><span class="s2">&quot;id: </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="s2">&quot;All cluster members disconnected before maintenance.&quot;</span><span class="p">)</span>

        <span class="n">sf</span><span class="p">:</span> <span class="n">sd</span><span class="o">.</span><span class="n">LoggingData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">log_off_nodes</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">log_lost_file_blocks</span><span class="p">(</span><span class="n">lost_parts_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">off_nodes</span></div>

<div class="viewcode-block" id="SGCluster.evaluate"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="s2">&quot;Cluster has no remaining members.&quot;</span><span class="p">)</span>

        <span class="n">plive</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ptotal</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avg_</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">ptotal</span> <span class="o">+=</span> <span class="n">c</span>
            <span class="n">plive</span> <span class="o">+=</span> <span class="n">c</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_up</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_evaluation</span><span class="p">(</span><span class="n">plive</span><span class="p">,</span> <span class="n">ptotal</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGCluster.maintain"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.maintain">[docs]</a>    <span class="k">def</span> <span class="nf">maintain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">off_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evicts any node who is referenced in off_nodes list.</span>

<span class="sd">        Extends:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.maintain`.</span>

<span class="sd">        Args:</span>
<span class="sd">            off_nodes (List[:py:class:`~app.type_hints.NodeType`]):</span>
<span class="sd">                The subset of :py:attr:`~Cluster.members` who disconnected</span>
<span class="sd">                during the current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_avg_</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">off_nodes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">remove_file_routing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">membership_maintenance</span><span class="p">()</span></div>

<div class="viewcode-block" id="SGCluster.membership_maintenance"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.membership_maintenance">[docs]</a>    <span class="k">def</span> <span class="nf">membership_maintenance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attempts to recruits new network nodes to be members of the cluster.</span>

<span class="sd">        The method updates both :py:attr:`members` and :py:attr:`_members_view`.</span>

<span class="sd">        Extends:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.membership_maintenance`.</span>

<span class="sd">            ``SGCluster.membership_maintenance`` adds and removes cloud</span>
<span class="sd">            references depending depending on the length of :py:attr:`~Cluster.members`</span>
<span class="sd">            before maintenance is performed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~app.type_hints.NodeDict`:</span>
<span class="sd">                A dictionary that is empty if membership did not change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_cloud_reference</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_cloud_reference</span><span class="p">()</span>

        <span class="n">new_members</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">membership_maintenance</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_and_bcast_new_transition_matrix</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_members</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Swarm guidance structure management</span>
<div class="viewcode-block" id="SGCluster.new_desired_distribution"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.new_desired_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">new_desired_distribution</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">member_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">member_uptimes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Sets a new :py:attr:`desired distribution &lt;v_&gt;` for the</span>
<span class="sd">        ``SGCluster``.</span>

<span class="sd">        Received ``member_uptimes`` are normalized to create a stochastic</span>
<span class="sd">        representation of the desired distribution, which can be used by the</span>
<span class="sd">        different transition matrix generation strategies.</span>

<span class="sd">        Args:</span>
<span class="sd">            member_ids:</span>
<span class="sd">                A list of :py:attr:`node identifiers</span>
<span class="sd">                &lt;app.domain.network_nodes.Node.id&gt;` who are</span>
<span class="sd">                :py:attr:`~Cluster.members` of the ``SGCluster``.</span>
<span class="sd">            member_uptimes:</span>
<span class="sd">                A list of :py:attr:`node identifiers</span>
<span class="sd">                &lt;app.domain.network_nodes.Node.uptime&gt;`.</span>

<span class="sd">        Note:</span>
<span class="sd">            ``member_ids`` and ``member_uptimes`` elements at each index should</span>
<span class="sd">            belong to each other, i.e., they should originate from from the</span>
<span class="sd">            same :py:class:`network node &lt;app.domain.network_nodes.SGNode&gt;`.</span>
<span class="sd">        Returns:</span>
<span class="sd">            A list of floats with normalized uptimes which represent the</span>
<span class="sd">            &quot;reliability&quot; of network nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uptime_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">member_uptimes</span><span class="p">)</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="p">[</span><span class="n">member_uptime</span> <span class="o">/</span> <span class="n">uptime_sum</span> <span class="k">for</span> <span class="n">member_uptime</span> <span class="ow">in</span> <span class="n">member_uptimes</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">v_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">u_</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">member_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">member_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">member_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">u_</span></div>

<div class="viewcode-block" id="SGCluster.new_transition_matrix"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.new_transition_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">new_transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new transition matrix that is likely to be a Markov Matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~pd:pandas.DataFrame`:</span>
<span class="sd">                The labeled matrix that has the fastests mixing rate from all</span>
<span class="sd">                the pondered strategies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_uptimes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">node_uptimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">uptime</span><span class="p">)</span>
            <span class="n">node_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">new_symmetric_connected_matrix</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">v_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">new_desired_distribution</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">node_uptimes</span><span class="p">))</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_fastest_topology</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">node_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGCluster.broadcast_transition_matrix"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.broadcast_transition_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">broadcast_transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Slices a  matrix and delivers columns to the respective</span>
<span class="sd">        :py:class:`network nodes &lt;app.domain.network_nodes.SGNode&gt;`.</span>

<span class="sd">        Args:</span>
<span class="sd">            m (:py:class:`~pd:pandas.DataFrame`)</span>
<span class="sd">                A matrix to be broadcasted to the network nodes</span>
<span class="sd">                belonging who are currently members of the Cluster instance.</span>

<span class="sd">        Note:</span>
<span class="sd">            An optimization could be made that configures a transition matrix</span>
<span class="sd">            for the cluster, independent of of file names, i.e., turn cluster</span>
<span class="sd">            groups into groups persisting multiple files instead of only one,</span>
<span class="sd">            thus reducing simulation spaceoverheads and in real-life</span>
<span class="sd">            scenarios, decreasing the load done to metadata servers, through</span>
<span class="sd">            queries and matrix calculations. For simplicity of implementation</span>
<span class="sd">            each cluster only manages one file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes_degrees</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out_degrees</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># columns</span>
        <span class="n">in_degrees</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># rows</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>
            <span class="n">nodes_degrees</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">in_degrees</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="si">}</span><span class="s2">i#o</span><span class="si">{</span><span class="n">out_degrees</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">transition_vector</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">nid</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">set_file_routing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">transition_vector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_matrices_degrees</span><span class="p">(</span><span class="n">nodes_degrees</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGCluster.create_and_bcast_new_transition_matrix"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.create_and_bcast_new_transition_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">create_and_bcast_new_transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Helper method that attempts to generate a markov matrix to be</span>
<span class="sd">        sliced and distributed to the ``SGCluster``</span>
<span class="sd">        :py:attr:`~Cluster.members`.</span>

<span class="sd">        At most three transition matrices will be generated. The first to be</span>
<span class="sd">        successfully :py:meth:`validated &lt;_validate_transition_matrix&gt;` is</span>
<span class="sd">        distributed to the :py:class:`network nodes</span>
<span class="sd">        &lt;app.domain.network_nodes.SGNode&gt;`. If all matrices are invalid,</span>
<span class="sd">        the last matrix will be used to prevent infinite loops in the</span>
<span class="sd">        simulation. This is not an issue as eventually the membership of the</span>
<span class="sd">        ``SGCluster`` will change, thus, more opportunities to perform a</span>
<span class="sd">        correct swarm guidance behavior will be possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">tries</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating new transition matrix... try #</span><span class="si">{</span><span class="n">tries</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">tries</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_transition_matrix</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_transition_matrix</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="c1"># Only tries to create a valid matrix up to five times before proceeding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_transition_matrix</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

    <span class="c1"># noinspection PyIncorrectDocstring</span>
<div class="viewcode-block" id="SGCluster.select_fastest_topology"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.select_fastest_topology">[docs]</a>    <span class="k">def</span> <span class="nf">select_fastest_topology</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates multiple transition matrices and selects the fastest.</span>

<span class="sd">        The fastest of the created transition matrices corresponds to the one</span>
<span class="sd">        with a faster mixing rate.</span>

<span class="sd">        Args:</span>
<span class="sd">            a (:py:class:`~np:numpy.ndarray`)</span>
<span class="sd">                An adjacency matrix that represents the network topology.</span>
<span class="sd">            `v_` (:py:class:`~np:numpy.ndarray`):</span>
<span class="sd">                A desired distribution vector that defines the returned</span>
<span class="sd">                matrix steady state property.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~np:numpy.ndarray`:</span>
<span class="sd">                A transition matrix that is likely to be a markov matrix whose</span>
<span class="sd">                steady state is ``v_``, but is not yet validated. See</span>
<span class="sd">                :py:meth:`_validate_transition_matrix`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mm</span><span class="o">.</span><span class="n">new_mh_transition_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">),</span>
            <span class="n">mm</span><span class="o">.</span><span class="n">new_sdp_mh_transition_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">),</span>
            <span class="n">mm</span><span class="o">.</span><span class="n">new_go_transition_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">),</span>
            <span class="n">mm</span><span class="o">.</span><span class="n">new_mgo_transition_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">min_mr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">fastest_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">i_mr</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i_mr</span> <span class="o">&lt;</span> <span class="n">min_mr</span><span class="p">:</span>
                <span class="c1"># print(f&quot;currently selected matrix {i}&quot;)</span>
                <span class="n">min_mr</span> <span class="o">=</span> <span class="n">i_mr</span>
                <span class="c1"># Worse case scenario fastest matrix will be the unoptmized MH.</span>
                <span class="n">fastest_matrix</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">fastest_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">fastest_matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fastest_matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">fastest_matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">fastest_matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fastest_matrix</span></div>

<div class="viewcode-block" id="SGCluster._validate_transition_matrix"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster._validate_transition_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_transition_matrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">v_</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Asserts if ``m`` is a Markov Matrix.</span>

<span class="sd">        Verification is done by raising the ``m`` to the power</span>
<span class="sd">        of ``4096`` (just a large number) and checking if all columns of the</span>
<span class="sd">        powered matrix are element-wise equal to the</span>
<span class="sd">        entries of ``target_distribution``.</span>

<span class="sd">        Args:</span>
<span class="sd">            m (:py:class:`~pd:pandas.DataFrame`):</span>
<span class="sd">                The matrix to be verified.</span>
<span class="sd">            `v_` (:py:class:`~pd:pandas.DataFrame`):</span>
<span class="sd">                The steady state the ``m`` is expected to have.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ``True`` if the matrix converges to the ``target_distribution``,</span>
<span class="sd">            otherwise ``False``. I.e., if ``m`` is a</span>
<span class="sd">            markov matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_pow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="mi">4096</span><span class="p">)</span>
        <span class="n">column_count</span> <span class="o">=</span> <span class="n">t_pow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">column_count</span><span class="p">):</span>
            <span class="n">test_target</span> <span class="o">=</span> <span class="n">t_pow</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># gets array column j</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                    <span class="n">test_target</span><span class="p">,</span> <span class="n">v_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-02</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Cloud management</span>
<div class="viewcode-block" id="SGCluster.remove_cloud_reference"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.remove_cloud_reference">[docs]</a>    <span class="k">def</span> <span class="nf">remove_cloud_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove cloud references and delete files within it</span>

<span class="sd">        Note:</span>
<span class="sd">            This method is virtual.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SGCluster.add_cloud_reference"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.add_cloud_reference">[docs]</a>    <span class="k">def</span> <span class="nf">add_cloud_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a cloud server to the :py:attr:`~Cluster.members` of</span>
<span class="sd">        the ``SGCluster``.</span>

<span class="sd">        This method is used when ``SGCluster`` membership size becomes</span>
<span class="sd">        compromised and a backup solution using cloud approaches is desired.</span>
<span class="sd">        The idea is that surviving members upload their replicas to the cloud</span>
<span class="sd">        server, e.g., an Amazon S3 instance. See Master method</span>
<span class="sd">        :py:meth:`~app.domain.master_servers.SGMaster.get_cloud_reference`</span>
<span class="sd">        for more details.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method is virtual.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Helpers</span>
<div class="viewcode-block" id="SGCluster.equal_distributions"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster.equal_distributions">[docs]</a>    <span class="k">def</span> <span class="nf">equal_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Asserts if the :py:attr:`desired distribution</span>
<span class="sd">        &lt;app.domain.cluster_groups.SGCluster.v_&gt;` and</span>
<span class="sd">        :py:attr:`current distribution</span>
<span class="sd">        &lt;app.domain.cluster_groups.SGCluster.cv_&gt;` are equal.</span>

<span class="sd">        Equalility is calculated using numpy allclose function which has the</span>
<span class="sd">        following formula: ::</span>

<span class="sd">            absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))</span>

<span class="sd">        Returns:</span>
<span class="sd">            ``True`` if distributions are close enough to be considered equal,</span>
<span class="sd">            otherwise, it returns ``False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">existing_replicas</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ptotal</span><span class="p">)</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">es</span><span class="o">.</span><span class="n">ATOL</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="n">ptotal</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">es</span><span class="o">.</span><span class="n">RTOL</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGCluster._log_evaluation"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster._log_evaluation">[docs]</a>    <span class="k">def</span> <span class="nf">_log_evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ptotal</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_log_evaluation</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="n">ptotal</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal_distributions</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">register_convergence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">save_sets_and_reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="SGCluster._normalize_avg_"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster._normalize_avg_">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize_avg_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_</span><span class="p">))</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="n">atol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_size</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">es</span><span class="o">.</span><span class="n">ATOL</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">goaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">avg_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">es</span><span class="o">.</span><span class="n">RTOL</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_topology_goal_performance</span><span class="p">(</span><span class="n">goaled</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGCluster._pretty_print_eq_distr_table"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGCluster._pretty_print_eq_distr_table">[docs]</a>    <span class="k">def</span> <span class="nf">_pretty_print_eq_distr_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pretty prints a PSQL formatted table for visual vector comparison.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (:py:class:`~pd:pandas.DataFrame`):</span>
<span class="sd">                The :py:class:`~pd:pandas.DataFrame` object to be formatted</span>
<span class="sd">                as PSQL table.</span>
<span class="sd">            atol:</span>
<span class="sd">                The allowed absolute tolerance.</span>
<span class="sd">            rtol:</span>
<span class="sd">                The allowed relative tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cv_&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;v_&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;(cv_ - v_)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">target</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rtol</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;(cv_ - v_)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;tolerance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;is_close&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">zipped</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tabulate</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="n">tablefmt</span><span class="o">=</span><span class="s1">&#39;psql&#39;</span><span class="p">)</span></div></div>
    <span class="c1"># endregion</span>


<div class="viewcode-block" id="SGClusterPerfect"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterPerfect">[docs]</a><span class="k">class</span> <span class="nc">SGClusterPerfect</span><span class="p">(</span><span class="n">SGCluster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a group of network nodes persisting a file using swarm</span>
<span class="sd">    guidance algorithm.</span>

<span class="sd">    This implementation assumes nodes never disconnect, there are no disk</span>
<span class="sd">    errors and there is no link loss, i.e., it is used to study properties of</span>
<span class="sd">    the system independently of computing environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SGClusterPerfect.__init__"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterPerfect.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">master</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">MasterType</span><span class="p">,</span>
                 <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">,</span>
                 <span class="n">sim_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="c1"># es.set_loss_chance(0.0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corruption_chances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span></div>

    <span class="c1"># region Swarm guidance structure management</span>
<div class="viewcode-block" id="SGClusterPerfect.new_desired_distribution"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterPerfect.new_desired_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">new_desired_distribution</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">member_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">member_uptimes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a random desired distribution.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.SGCluster.new_desired_distribution`</span>

<span class="sd">        Args:</span>
<span class="sd">            member_ids:</span>
<span class="sd">                A list of :py:attr:`node identifiers</span>
<span class="sd">                &lt;app.domain.network_nodes.Node.id&gt;` who are</span>
<span class="sd">                :py:attr:`~Cluster.members` of the ``SGCluster``.</span>
<span class="sd">            member_uptimes:</span>
<span class="sd">                This method&#39;s parameter is ignored and can be ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~np:numpy.ndarray`:</span>
<span class="sd">                A list of floats with which represent how the files should be</span>
<span class="sd">                distributed among network nodes in the long-run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">member_ids</span><span class="p">))</span>
        <span class="n">u_</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">v_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">u_</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">member_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">member_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">member_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">u_</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation steps</span>
<div class="viewcode-block" id="SGClusterPerfect.execute_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterPerfect.execute_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span> <span class="o">=</span> <span class="n">epoch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_execute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">==</span> <span class="n">ms</span><span class="o">.</span><span class="n">Master</span><span class="o">.</span><span class="n">MAX_EPOCHS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_avg_</span><span class="p">()</span></div>

<div class="viewcode-block" id="SGClusterPerfect.nodes_execute"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterPerfect.nodes_execute">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Queries all network node members execute the epoch.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.nodes_execute`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~app.type_hints.NodeType`]:</span>
<span class="sd">                 A collection of members who disconnected during the current</span>
<span class="sd">                 epoch. See</span>
<span class="sd">                 :py:meth:`app.domain.network_nodes.Node.update_status`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Helpers</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def select_fastest_topology(</span>
<span class="sd">            self, a: np.ndarray, v_: np.ndarray) -&gt; np.ndarray:</span>
<span class="sd">        fastest_matrix, _ = mm.new_mh_transition_matrix(a, v_)</span>
<span class="sd">        size = fastest_matrix.shape[0]</span>
<span class="sd">        for j in range(size):</span>
<span class="sd">            fastest_matrix[:, j] = np.absolute(fastest_matrix[:, j])</span>
<span class="sd">            fastest_matrix[:, j] /= fastest_matrix[:, j].sum()</span>
<span class="sd">        return fastest_matrix</span>
<span class="sd">    &quot;&quot;&quot;</span></div>
    <span class="c1"># endregion</span>


<div class="viewcode-block" id="SGClusterExt"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterExt">[docs]</a><span class="k">class</span> <span class="nc">SGClusterExt</span><span class="p">(</span><span class="n">SGCluster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a group of network nodes persisting a file.</span>

<span class="sd">    ``SGClusterExt`` instances differ from</span>
<span class="sd">    :py:class:`~app.domain.cluster_groups.SGCluster` because their members are</span>
<span class="sd">    of type :py:class:`~app.domain.network_nodes.SGNodeExt`. When combined</span>
<span class="sd">    these classes give nodes the responsibility of collaborating in the</span>
<span class="sd">    detection of faulty members of the ``SGClusterExt`` and eventually</span>
<span class="sd">    kicking them out of the group.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        complaint_threshold (int):</span>
<span class="sd">            Reference value that defines the maximum number of complaints a</span>
<span class="sd">            :py:class:`network node &lt;app.domain.network_nodes.SGNodeExt&gt;`</span>
<span class="sd">            can receive before it is evicted from the ``SGClusterExt``.</span>
<span class="sd">        nodes_complaints (Dict[str, int]):</span>
<span class="sd">            A dictionary mapping :py:attr:`network node identifiers&#39;</span>
<span class="sd">            &lt;app.domain.network_nodes.Node.id&gt;` to the number of complaints</span>
<span class="sd">            made against them by other :py:attr:`~Cluster.members`. When</span>
<span class="sd">            complaints becomes bigger than py:py:attr:`complaint_threshold`</span>
<span class="sd">            the complaintee is evicted from the group.</span>
<span class="sd">        suspicious_nodes (Dict[str, int]):</span>
<span class="sd">            A dictionary containing the unique :py:attr:`node identifiers</span>
<span class="sd">            &lt;app.domain.network_nodes.Node.id&gt;` of known suspicious</span>
<span class="sd">            members and how many epochs have passed since they changed to such</span>
<span class="sd">            status.</span>
<span class="sd">        _epoch_complaints (set):</span>
<span class="sd">            A set of unique identifiers formed from the concatenation of</span>
<span class="sd">            :py:attr:`node identifiers &lt;app.domain.network_nodes.Node.id&gt;`,</span>
<span class="sd">            to avoid multiple complaint registrations on the same epoch,</span>
<span class="sd">            done by the same source towards the same target. The set is</span>
<span class="sd">            reset every epoch.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SGClusterExt.__init__"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterExt.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">master</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">MasterType</span><span class="p">,</span>
                 <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">,</span>
                 <span class="n">sim_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complaint_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_complaints</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>

    <span class="c1"># region Cluster API</span>
<div class="viewcode-block" id="SGClusterExt.complain"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterExt.complain">[docs]</a>    <span class="k">def</span> <span class="nf">complain</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">complainter</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">complainee</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">HttpResponse</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Registers a complaint against a possibly offline node.</span>

<span class="sd">        A unique identifier for the complaint is generated by concatenation</span>
<span class="sd">        of the complainter and the complainee unique identifiers.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.complain`</span>

<span class="sd">        Args:</span>
<span class="sd">            complainter:</span>
<span class="sd">                The identifier of the complaining</span>
<span class="sd">                :py:class:`~app.domain.network_nodes.SGNodeExt`.</span>
<span class="sd">            complainee:</span>
<span class="sd">                The identifier of the</span>
<span class="sd">                :py:class:`~app.domain.network_nodes.SGNodeExt`</span>
<span class="sd">                being complained about.</span>
<span class="sd">            reason (:py:data:`app.type_hints.HttpResponse`):</span>
<span class="sd">                The :py:class:`http code &lt;app.domain.helpers.enums.HttpCodes&gt;`</span>
<span class="sd">                that led to the complaint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">HttpCodes</span><span class="o">.</span><span class="n">TIME_OUT</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">complaint_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">complainter</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">complainee</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">complaint_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_complaints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_complaints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">complaint_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">complainee</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="p">[</span><span class="n">complainee</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="p">[</span><span class="n">complainee</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    &gt; Logged complaint </span><span class="si">{</span><span class="n">complaint_id</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;complainee complaint count: &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="p">[</span><span class="n">complainee</span><span class="p">]</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">complaint_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation steps</span>
<div class="viewcode-block" id="SGClusterExt.execute_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterExt.execute_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_complaints</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="SGClusterExt.nodes_execute"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterExt.nodes_execute">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Queries all network node members execute the epoch.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.SGCluster.nodes_execute`.</span>

<span class="sd">            Offline :py:class:`network nodes &lt;app.domain.network_nodes.SGNodeExt&gt;`</span>
<span class="sd">            are considered suspects until enough complaints</span>
<span class="sd">            from other ``SGNodeExt`` :py:attr:`~Cluster.members` are received.</span>
<span class="sd">            This is important because lost parts can not be logged multiple</span>
<span class="sd">            times. Yet suspected :py:class:`network nodes</span>
<span class="sd">            &lt;app.domain.network_nodes.SGNodeExt&gt;` need to be contabilized</span>
<span class="sd">            as offline for simulation purposes without being evicted from the</span>
<span class="sd">            group until they are detected by their peers as being offline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~app.type_hints.NodeType`]:</span>
<span class="sd">                A collection of :py:attr:`~Cluster.members` who disconnected</span>
<span class="sd">                during the current epoch.</span>
<span class="sd">                See :py:meth:`app.domain.network_nodes.SGNodeExt.update_status`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lost_parts_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">off_nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_up</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">is_suspect</span><span class="p">()</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span>
                <span class="n">node_replicas</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">lost_parts_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_replicas</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">node_replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">replica</span><span class="o">.</span><span class="n">decrement_and_get_references</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lost all replicas of file replica &quot;</span>
                                       <span class="sa">f</span><span class="s2">&quot;with id: </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">complaints</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">complaints</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">complaint_threshold</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span>
                <span class="n">node_replicas</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">node_replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_replication_epoch</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
                <span class="n">off_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="s2">&quot;All cluster members disconnected before maintenance.&quot;</span><span class="p">)</span>

        <span class="n">sf</span><span class="p">:</span> <span class="n">sd</span><span class="o">.</span><span class="n">LoggingData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">log_off_nodes</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">log_lost_file_blocks</span><span class="p">(</span><span class="n">lost_parts_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">off_nodes</span></div>

<div class="viewcode-block" id="SGClusterExt.maintain"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.SGClusterExt.maintain">[docs]</a>    <span class="k">def</span> <span class="nf">maintain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">off_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evicts any :py:class:`network node</span>
<span class="sd">        &lt;app.domain.network_nodes.SGNodeExt&gt;` who has</span>
<span class="sd">        been complained about more than :py:attr:`complaint_threshold` times.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.maintain`.</span>

<span class="sd">        Args:</span>
<span class="sd">            off_nodes (List[:py:class:`~app.type_hints.NodeType`]):</span>
<span class="sd">                The subset of :py:attr:`~Cluster.members` who disconnected</span>
<span class="sd">                during the current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_avg_</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_membership_changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">off_nodes</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    [o] Evicted suspect </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_complaints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># node.remove_file_routing(self.file.name)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span> <span class="o">-</span> <span class="n">t</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_suspicous_node_detection_delay</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">membership_maintenance</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complaint_threshold</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span></div></div>
    <span class="c1"># endregion</span>


<div class="viewcode-block" id="HDFSCluster"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.HDFSCluster">[docs]</a><span class="k">class</span> <span class="nc">HDFSCluster</span><span class="p">(</span><span class="n">Cluster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a group of network nodes ensuring the durability of a file</span>
<span class="sd">    in a Hadoop Distributed File System scenario.</span>

<span class="sd">    Note:</span>
<span class="sd">        Members of ``HDFSCluster`` are of type</span>
<span class="sd">        :py:class:`~app.domain.network_nodes.HDFSNode`, they do not</span>
<span class="sd">        perform swarm guidance behaviors and instead report with regular</span>
<span class="sd">        heartbeats to their :py:class:`monitors</span>
<span class="sd">        &lt;app.domain.cluster_groups.HDFSCluster&gt;`. This class could be a</span>
<span class="sd">        *NameNode Server* in HDFS or a *master server* in GFS.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        suspicious_nodes (set):</span>
<span class="sd">            A set containing the identifiers of suspicious</span>
<span class="sd">            :py:class:`network nodes &lt;app.domain.network_nodes.HDFSNode&gt;`.</span>
<span class="sd">        data_node_heartbeats (Dict[str, int]):</span>
<span class="sd">            A dictionary mapping :py:attr:`node identifiers</span>
<span class="sd">            &lt;app.domain.network_nodes.Node.id&gt;` to the number of</span>
<span class="sd">            complaints made against them. Each node has five lives. When they</span>
<span class="sd">            miss five beats in a row, i.e., when the dictionary value count</span>
<span class="sd">            is zero, they are evicted from the cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HDFSCluster.__init__"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.HDFSCluster.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">master</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">MasterType</span><span class="p">,</span>
                 <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">,</span>
                 <span class="n">sim_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_node_heartbeats</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="mi">5</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">members</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">}</span></div>

    <span class="c1"># region Simulation steps</span>
<div class="viewcode-block" id="HDFSCluster.nodes_execute"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.HDFSCluster.nodes_execute">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Queries all :py:attr:`~Cluster.members` to execute the epoch.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.nodes_execute`</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~app.type_hints.NodeType`]:</span>
<span class="sd">                A collection of :py:attr:`~Cluster.members` who disconnected</span>
<span class="sd">                during the current epoch. See</span>
<span class="sd">                :py:meth:`app.domain.network_nodes.HDFSNode.update_status`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">off_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lost_replicas_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_up</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">is_suspect</span><span class="p">():</span>
                <span class="c1"># Register lost replicas the moment the node disconnects.</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="n">node_replicas</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">lost_replicas_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_replicas</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">node_replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">replica</span><span class="o">.</span><span class="n">decrement_and_get_references</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lost all replicas of file replica &quot;</span>
                                           <span class="sa">f</span><span class="s2">&quot;with id: </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Simulate missed heartbeats.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_node_heartbeats</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    &gt; Logged missed heartbeat </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">, node remaining&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot; lives: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data_node_heartbeats</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_node_heartbeats</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">off_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">node_replicas</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">node_replicas</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_replication_epoch</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="s2">&quot;All data nodes disconnected before maintenance.&quot;</span><span class="p">)</span>

        <span class="n">sf</span><span class="p">:</span> <span class="n">sd</span><span class="o">.</span><span class="n">LoggingData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">log_off_nodes</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">log_lost_file_blocks</span><span class="p">(</span><span class="n">lost_replicas_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_epoch</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">off_nodes</span></div>

<div class="viewcode-block" id="HDFSCluster.evaluate"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.HDFSCluster.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Logs the number of existing replicas in the ``HDFSCluster``.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.evaluate`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fail</span><span class="p">(</span><span class="s2">&quot;Cluster has no remaining members.&quot;</span><span class="p">)</span>

        <span class="n">plive</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_up</span><span class="p">():</span>
                <span class="n">node_replicas</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_file_parts_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">plive</span> <span class="o">+=</span> <span class="n">node_replicas</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_evaluation</span><span class="p">(</span><span class="n">plive</span><span class="p">)</span></div>

<div class="viewcode-block" id="HDFSCluster.maintain"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.HDFSCluster.maintain">[docs]</a>    <span class="k">def</span> <span class="nf">maintain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">off_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evicts any :py:class:`network node &lt;app.domain.network_nodes.HDFSNode&gt;`</span>
<span class="sd">        whose heartbeats in :py:attr:`data_node_heartbeats` reached zero.</span>

<span class="sd">        Extends:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.execute_epoch`.</span>

<span class="sd">        Args:</span>
<span class="sd">            off_nodes (List[:py:class:`~app.type_hints.NodeType`]):</span>
<span class="sd">                The subset of :py:attr:`~Cluster.members` who disconnected</span>
<span class="sd">                during the current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">maintain</span><span class="p">(</span><span class="n">off_nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">off_nodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    [o] Evicted suspect </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suspicious_nodes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_node_heartbeats</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log_suspicous_node_detection_delay</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">membership_maintenance</span><span class="p">()</span></div>

<div class="viewcode-block" id="HDFSCluster.membership_maintenance"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.HDFSCluster.membership_maintenance">[docs]</a>    <span class="k">def</span> <span class="nf">membership_maintenance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">:</span>
        <span class="n">new_members</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">membership_maintenance</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">new_members</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_node_heartbeats</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span></div></div>
    <span class="c1"># endregion</span>


<div class="viewcode-block" id="NewscastCluster"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster">[docs]</a><span class="k">class</span> <span class="nc">NewscastCluster</span><span class="p">(</span><span class="n">Cluster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a P2P network of nodes performing mean degree aggregation,</span>
<span class="sd">    while simultaneously using Newscast for ``view shuffling``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NewscastCluster.__init__"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">master</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">MasterType</span><span class="p">,</span>
                 <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">members</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">NodeDict</span><span class="p">,</span>
                 <span class="n">sim_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span></div>

    <span class="c1"># region Cluster API</span>
    <span class="c1"># noinspection PyAttributeOutsideInit</span>
<div class="viewcode-block" id="NewscastCluster.log_aggregation"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.log_aggregation">[docs]</a>    <span class="k">def</span> <span class="nf">log_aggregation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count_min</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count_min</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count_max</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count_max</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrsum</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">value</span></div>

<div class="viewcode-block" id="NewscastCluster.wire_k_out"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.wire_k_out">[docs]</a>    <span class="k">def</span> <span class="nf">wire_k_out</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a random directed P2P topology.</span>

<span class="sd">        The initial cache size of each :py:class:`network node</span>
<span class="sd">        &lt;app.domain.network_nodes.NewscastNode&gt;`, is at most as big as</span>
<span class="sd">        :py:const:`~app.environment_settings.NEWSCAST_CACHE_SIZE`.</span>

<span class="sd">        Note:</span>
<span class="sd">            The topology does not have self loops, because</span>
<span class="sd">            :py:meth:`~app.domain.network_nodes.NewscastNode.add_neighbor`</span>
<span class="sd">            does not accept node self addition to</span>
<span class="sd">            :py:attr:`~app.domain.network_nodes.NewscastNode.view`. In rare</span>
<span class="sd">            occasions, the selected node out-going edges might all be</span>
<span class="sd">            invalid, this should be a non-issue, as the nodes will eventually</span>
<span class="sd">            join the overaly throughout the simulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">network_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">network_size</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">network_size</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">es</span><span class="o">.</span><span class="n">NEWSCAST_CACHE_SIZE</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">member</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">another_member</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">member</span><span class="o">.</span><span class="n">add_neighbor</span><span class="p">(</span><span class="n">another_member</span><span class="p">)</span></div>

    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation steps</span>
<div class="viewcode-block" id="NewscastCluster.execute_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.execute_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_execute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">epoch</span> <span class="o">==</span> <span class="n">ms</span><span class="o">.</span><span class="n">Master</span><span class="o">.</span><span class="n">MAX_EPOCHS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="NewscastCluster.nodes_execute"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.nodes_execute">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">th</span><span class="o">.</span><span class="n">NodeType</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Queries all network node members execute the epoch.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster.nodes_execute`.</span>

<span class="sd">            Note:</span>
<span class="sd">                :py:meth:`NewscasterCluster.nodes_execute</span>
<span class="sd">                &lt;app.domain.cluster_groups.NewscastNode.nodes_execute&gt;`</span>
<span class="sd">                always returns None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~app.type_hints.NodeType`]:</span>
<span class="sd">                 A collection of members who disconnected during the current</span>
<span class="sd">                 epoch. See</span>
<span class="sd">                 :py:meth:`app.domain.network_nodes.NewscastNode.update_status`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_members_view</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">execute_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="NewscastCluster.evaluate"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prints the epoch&#39;s aggregated peer degree, to the command-line</span>
<span class="sd">        interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">({</span>
            <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
            <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
            <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
            <span class="s2">&quot;count_min&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_min</span><span class="p">,</span>
            <span class="s2">&quot;count_max&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_max</span>
        <span class="p">})</span></div>
    <span class="c1"># endregion</span>

    <span class="c1"># region Simulation setup</span>
<div class="viewcode-block" id="NewscastCluster._setup_epoch"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster._setup_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initializes some attributes cluster attributes at the start of an</span>
<span class="sd">        epoch.</span>

<span class="sd">        Extends:</span>
<span class="sd">            :py:meth:`app.domain.cluster_groups.Cluster._setup_epoch`</span>

<span class="sd">        Args:</span>
<span class="sd">            epoch:</span>
<span class="sd">                The simulation&#39;s current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setup_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrsum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="NewscastCluster.spread_files"><a class="viewcode-back" href="../../../app.domain.html#app.domain.cluster_groups.NewscastCluster.spread_files">[docs]</a>    <span class="k">def</span> <span class="nf">spread_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replicas</span><span class="p">:</span> <span class="n">th</span><span class="o">.</span><span class="n">ReplicasDict</span><span class="p">,</span> <span class="n">strat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Distributes a collection of :py:class:`file block replicas</span>
<span class="sd">        &lt;app.domain.helpers.smart_dataclasses.FileBlockData&gt;` among the</span>
<span class="sd">        :py:attr:`members` of the cluster group.</span>

<span class="sd">        Overrides:</span>
<span class="sd">            :py:meth:`app.dommain.cluster_groups.Cluster.spread_files`</span>

<span class="sd">        Args:</span>
<span class="sd">            replicas (:py:class:`~app.type_hints.ReplicasDict`):</span>
<span class="sd">                The :py:class:`~app.domain.helpers.smart_dataclasses.FileBlockData`</span>
<span class="sd">                replicas, without replication.</span>
<span class="sd">            strat:</span>
<span class="sd">                Defines how ``replicas`` will be initially distributed in</span>
<span class="sd">                the ``Cluster``. Unless overridden in children of this class the</span>
<span class="sd">                received value of ``strat`` will be ignored and will always</span>
<span class="sd">                be set to the default value ``o``.</span>

<span class="sd">                o</span>
<span class="sd">                    This strategy assumes erasure-coding is being used and</span>
<span class="sd">                    that each :py:class:`network node</span>
<span class="sd">                    &lt;app.domain.network_nodes.Node&gt;` will have no more than</span>
<span class="sd">                    one encoded block, i.e., replication level is always</span>
<span class="sd">                    equal to one. Note however, that if there are more encoded</span>
<span class="sd">                    blocks than there are :py:class:`network nodes</span>
<span class="sd">                    &lt;app.domain.network_nodes.Node&gt;`, some of these ``nodes``</span>
<span class="sd">                    might end up possessing an excessive amount of blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">initial_spread</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span>

        <span class="c1"># Can not use tuple in replicas because tuples are immutable.</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">replicas</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">members</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">members_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">replicas</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">members_len</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">member</span><span class="p">,</span> <span class="n">replica</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">replicas</span><span class="p">):</span>
                <span class="n">member</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">replicas</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">member</span><span class="p">,</span> <span class="n">replica</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">replicas</span><span class="p">):</span>
                    <span class="n">member</span><span class="o">.</span><span class="n">receive_part</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">replicas</span><span class="p">[:</span><span class="n">members_len</span><span class="p">]</span></div></div>
    <span class="c1"># endregion</span>
</pre></div>

            </div>

        </section>

        

        
            <div class="source-link">
            
                
            
            </div>
        



    </main>

    <footer class="site-footer">
<div class="container">

    <div role="contentinfo">
        <p>
                &copy; Copyright 2020, Francisco Barros.
        </p>
    </div>
        <p>Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
        <a href="https://github.com/testthedocs/sphinx_ttd_theme">theme</a>
        provided by <a href="https://testthedocs">TestTheDocs</a>. 

</div>
</footer>

    

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'',
            VERSION:'1.6.0rc1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/theme-min.js"></script> 
</body>
</html>